<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Eqaf (eqaf.Eqaf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">eqaf</a> &#x00BB; Eqaf</nav><h1>Module <code>Eqaf</code></h1><p>Eqaf - timing-safe comparison functions</p><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>In cryptography, a timing-attack is a side-channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms.</p><p>In some cases, a process needs to compare two values (input value and expected password). An attacker can analyze time needed by <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>/<span class="xref-unresolved" title="unresolved reference to &quot;String.equal&quot;"><code>String</code>.equal</span> to calculate expected password.</p><p>This side-channel attack is due implementation of <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>/<span class="xref-unresolved" title="unresolved reference to &quot;String.equal&quot;"><code>String</code>.equal</span> which leaves as soon as possible when it reachs a difference between <code>a</code> and <code>b</code>. By this way, time taken to compare two values differs if they are equal or not.</p><p>Distribution provides a little example of this kind of attack where we construct step by step (byte per byte) expected value from time spended to execute <code>compare</code>.</p><p>Distribution wants to provide some functions which protect user against this kind of attack:</p><ul><li><code>equal</code> like <span class="xref-unresolved" title="unresolved reference to &quot;String.equal&quot;"><code>String</code>.equal</span></li><li><code>compare_be</code> like <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span></li><li><code>compare_le</code> which is a <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span> with a reverse operation on inputs</li></ul><p>These functions are tested to see how long they took to compare two equal values and two different values. See <i>check</i> tool for more informations.</p><nav class="toc"><ul><li><a href="#implementations">Implementations</a></li></ul></nav></header><section><header><h3 id="implementations"><a href="#implementations" class="anchor"></a>Implementations</h3></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> returns <code>true</code> if <code>a</code> and <code>b</code> are equals. <code>String.equal a b =
   equal a b</code> for any <code>a</code> and <code>b</code>. The execution time of <code>equal</code> depends solely on the length of the strings, not the contents.</p></dd></dl><dl><dt class="spec value" id="val-compare_be"><a href="#val-compare_be" class="anchor"></a><code><span class="keyword">val</span> compare_be : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_be a b</code> returns <code>0</code> if <code>a</code> is equal to <code>b</code>, a negative integer if <code>a</code> if <i>less</i> (lexicographically) than <code>b</code>, and a positive integer if <code>a</code> is <i>greater</i> (lexicographically) than <code>b</code>.</p><p><code>compare_be a b</code> returns the same <i>order</i> than <code>String.compare a b</code> for any <code>a</code> and <code>b</code> (but not necessary the same integer!). Order is defined as:</p><ul><li><code>compare_be a b &lt; 0</code> means <code>a &lt; b</code></li><li><code>compare_be a b &gt; 0</code> means <code>a &gt; b</code></li><li><code>compare_be a b = 0</code> means <code>a = b</code></li></ul><p>About time, if <code>String.length a &lt;&gt; String.length b</code>, <code>compare_be</code> does not look into <code>a</code> or <code>b</code> and no comparison in bytes will be done.</p></dd></dl><dl><dt class="spec value" id="val-compare_be_with_len"><a href="#val-compare_be_with_len" class="anchor"></a><code><span class="keyword">val</span> compare_be_with_len : len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_be_with_len ~len a b</code> does <code>compare_be a b</code> on <code>len</code> bytes.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-compare_le"><a href="#val-compare_le" class="anchor"></a><code><span class="keyword">val</span> compare_le : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_le a b</code> is semantically <code>compare_be (rev a) (rev b)</code>. With <code>rev</code> reverses a string (<code>a = rev (rev a)</code>).</p></dd></dl><dl><dt class="spec value" id="val-compare_le_with_len"><a href="#val-compare_le_with_len" class="anchor"></a><code><span class="keyword">val</span> compare_le_with_len : len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_le_with_len a b</code> is semantically <code>compare_be_with_len ~len (rev a)
   (rev b)</code>. With <code>rev</code> reverse a string (<code>a = rev (rev a)</code>).</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></dd></dl></dd></dl></section></div></body></html>