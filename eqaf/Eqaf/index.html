<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Eqaf (eqaf.Eqaf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">eqaf</a> &#x00BB; Eqaf</nav><header class="odoc-preamble"><h1>Module <code><span>Eqaf</span></code></h1><p>Eqaf - constant time / timing side channel resistant functions</p></header><nav class="odoc-toc"><ul><li><a href="#basics">Basics</a></li><li><a href="#comparison-functions">Comparison functions</a><ul><li><a href="#equal">Equal</a></li><li><a href="#big-endian-comparison">Big-endian comparison</a></li><li><a href="#little-endian-comparison">Little-endian comparison</a></li></ul></li><li><a href="#arithmetic">Arithmetic</a><ul><li><a href="#division">Division</a></li></ul></li><li><a href="#stringutil">String utilities</a><ul><li><a href="#string-search">String search</a></li><li><a href="#ascii">ASCII functions</a></li><li><a href="#hex">Hex encoding and decoding</a></li></ul></li><li><a href="#low-level-primitives">Low-level primitives</a><ul><li><a href="#bithacks">Bithacks</a></li><li><a href="#composition">Composition</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>In cryptography, a timing-attack is a side-channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms.</p><p>In some cases, a process needs to compare two values (input value and expected password). An attacker can analyze time needed by <code>String</code>.compare/<code>String</code>.equal to calculate expected password.</p><p>This side-channel attack is due implementation of <code>String</code>.compare/<code>String</code>.equal which leaves as soon as possible when it reachs a difference between <code>a</code> and <code>b</code>. By this way, time taken to compare two values differs if they are equal or not.</p><p>Distribution provides a little example of this kind of attack where we construct step by step (byte per byte) expected value from time spended to execute <code>Stdlib</code>.compare.</p><p>Distribution wants to provide some functions which protect user against this kind of attack:</p><ul><li><code>equal</code> like <code>String</code>.equal</li><li><code>compare_be</code> like <code>String</code>.compare</li><li><code>compare_le</code> which is a <code>String</code>.compare with a reverse operation on inputs</li><li><a href="#val-divmod"><code>divmod</code></a> like <code>Int32</code>.unsigned_div and <code>Int32</code>.unsigned_rem</li></ul><p>These functions are tested to see how long they took to compare two equal values and two different values. See <i>check</i> tool for more informations.</p><h2 id="comparison-functions"><a href="#comparison-functions" class="anchor"></a>Comparison functions</h2><h3 id="equal"><a href="#equal" class="anchor"></a>Equal</h3><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> returns <code>true</code> if <code>a</code> and <code>b</code> are equals. <code>String.equal a b =
   equal a b</code> for any <code>a</code> and <code>b</code>. The execution time of <code>equal</code> depends solely on the length of the strings, not the contents.</p></div></div><h3 id="big-endian-comparison"><a href="#big-endian-comparison" class="anchor"></a>Big-endian comparison</h3><div class="odoc-spec"><div class="spec value" id="val-compare_be" class="anchored"><a href="#val-compare_be" class="anchor"></a><code><span><span class="keyword">val</span> compare_be : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_be a b</code> returns <code>0</code> if <code>a</code> is equal to <code>b</code>, a negative integer if <code>a</code> if <i>less</i> (lexicographically) than <code>b</code>, and a positive integer if <code>a</code> is <i>greater</i> (lexicographically) than <code>b</code>.</p><p><code>compare_be a b</code> returns the same <i>order</i> than <code>String.compare a b</code> for any <code>a</code> and <code>b</code> (but not necessary the same integer!). Order is defined as:</p><ul><li><code>compare_be a b &lt; 0</code> means <code>a &lt; b</code></li><li><code>compare_be a b &gt; 0</code> means <code>a &gt; b</code></li><li><code>compare_be a b = 0</code> means <code>a = b</code></li></ul><p>About time, if <code>String.length a &lt;&gt; String.length b</code>, <code>compare_be</code> does not look into <code>a</code> or <code>b</code> and no comparison in bytes will be done.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_be_with_len" class="anchored"><a href="#val-compare_be_with_len" class="anchor"></a><code><span><span class="keyword">val</span> compare_be_with_len : <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_be_with_len ~len a b</code> does <a href="#val-compare_be"><code>compare_be</code></a><code> a b</code> on <code>len</code> bytes.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></li></ul></div></div><h3 id="little-endian-comparison"><a href="#little-endian-comparison" class="anchor"></a>Little-endian comparison</h3><div class="odoc-spec"><div class="spec value" id="val-compare_le" class="anchored"><a href="#val-compare_le" class="anchor"></a><code><span><span class="keyword">val</span> compare_le : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_le a b</code> is semantically <code>compare_be (rev a) (rev b)</code>, where <code>rev</code> is a function that reverses a string bytewise (<code>a = rev (rev a)</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_le_with_len" class="anchored"><a href="#val-compare_le_with_len" class="anchor"></a><code><span><span class="keyword">val</span> compare_le_with_len : <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_le_with_len a b</code> is semantically <code>compare_be_with_len ~len (rev a)
   (rev b)</code>. With <code>rev</code> reverse a string (<code>a = rev (rev a)</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></li></ul></div></div><h2 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h2><h3 id="division"><a href="#division" class="anchor"></a>Division</h3><div class="odoc-spec"><div class="spec value" id="val-divmod" class="anchored"><a href="#val-divmod" class="anchor"></a><code><span><span class="keyword">val</span> divmod : <span>x:int32 <span class="arrow">&#45;&gt;</span></span> <span>m:int32 <span class="arrow">&#45;&gt;</span></span> int32 * int32</span></code></div><div class="spec-doc"><p>32-bit unsigned division with remainder, constant-time with respect to <code>x</code> (<b>not</b> <code>m</code>).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">x</span> <p>Dividend (number to be divided). <b>Can be secret</b>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">m</span> <p>Divisor <b>Must not be secret</b>. Must be <code>0 &lt; m &lt; 16384</code></p><p>This function is useful for implementation that need to produce e.g. pincodes from binary values in int32 format, example: <code>ascii_of_int32</code>.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>quotient, remainder</code></p><p>Example:</p><pre><code>let ct = Eqaf.divmod ~x ~m in
let not_ct = Int32.unsigned_div x m, Int32.unsigned_rem x m in
assert ct = not_ct ;</code></pre><p>That is, an attacker might be able to learn <code>m</code> by measuring execution time, but not the value of <code>x</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>when <code>not (0 &lt; m &amp;&amp; m &lt; 16384)</code>.</p></li></ul><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <span class="value">supercop/crypto_kem/sntrup761/ref/uint32.c</span> <p>Adapted from the NTRU Prime team's algorithm from <code>supercop/sntrup761</code>, see round-2 NTRU Prime submission to NISTPQC (March 2019).</p></li></ul></div></div><h2 id="stringutil"><a href="#stringutil" class="anchor"></a>String utilities</h2><h3 id="string-search"><a href="#string-search" class="anchor"></a>String search</h3><div class="odoc-spec"><div class="spec value" id="val-find_uint8" class="anchored"><a href="#val-find_uint8" class="anchor"></a><code><span><span class="keyword">val</span> find_uint8 : <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span>int <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>find_uint8 ?off ~f v</code> returns the index of the first occurrence which respects the predicate <code>f</code> in string <code>v</code>. Otherwise, it returns <code>-1</code>. The caller is responsible for ensuring that <code>~f</code> operates in constant time. The <a href="#val-bool_of_int"><code>bool_of_int</code></a> function can be relevant when writing <code>~f</code> functions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists_uint8" class="anchored"><a href="#val-exists_uint8" class="anchor"></a><code><span><span class="keyword">val</span> exists_uint8 : <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span>int <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists_uint8 ?off ~f v</code> tests if an occurrence respects the predicate <code>f</code> in the string <code>v</code>.</p></div></div><h3 id="ascii"><a href="#ascii" class="anchor"></a>ASCII functions</h3><div class="odoc-spec"><div class="spec value" id="val-ascii_of_int32" class="anchored"><a href="#val-ascii_of_int32" class="anchor"></a><code><span><span class="keyword">val</span> ascii_of_int32 : <span>digits:int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>ascii_of_int64 ~digits ~n</code> is a string consisting of the rightmost <code>digits</code> characters of the decimal representation of <code>n</code>. If <code>digits</code> is larger than the decimal representation, it is left-padded with <code>'0'</code>. If <code>digits</code> is smaller, the output is truncated.</p><p>Example:</p><pre><code>let s1 = ascii_of_int64 ~digits:6 ~n:12345678L in
assert (s = &quot;345678&quot;) ;
let s2 = ascii_of_int64 ~digits:6 ~n:1234L in
assert (s = &quot;001234&quot;) ;</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>when <code>digits &lt; 0</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase_ascii" class="anchored"><a href="#val-lowercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lowercase_ascii str</code> is <code>str</code> where <code>A-Z</code> is replaced with <code>a-z</code>. It is a constant time implementation of <code>String</code>.lowercase_ascii</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase_ascii" class="anchored"><a href="#val-uppercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>uppercase_ascii str</code> is <code>str</code> where <code>a-z</code> is replaced with <code>A-Z</code>. It is a constant time implementation of <code>String</code>.uppercase_ascii</p></div></div><h3 id="hex"><a href="#hex" class="anchor"></a>Hex encoding and decoding</h3><div class="odoc-spec"><div class="spec value" id="val-hex_of_bytes" class="anchored"><a href="#val-hex_of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> hex_of_bytes : <span>bytes <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>hex_of_bytes raw</code> is <code>raw</code> hex-encoded in constant time. Can be used to serialize sensitive values. The <b>contents can be secret</b>, but an attacker can learn the <b>length of</b> <code>raw</code> by timing this function.</p><p>Hex has two valid forms, lowercase and uppercase. This function produces lowercase hex characters exclusively.</p><p>Example:</p><pre><code>let secret = &quot;--Hi\x24&quot; in
let serialized = hex_of_string secret in
(* serialized is now &quot;2d2d486924&quot; *)</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">raw</span> <p>is the source buffer. <code>raw</code> is not mutated by this function.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-hex_of_string" class="anchored"><a href="#val-hex_of_string" class="anchor"></a><code><span><span class="keyword">val</span> hex_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>hex_of_string raw</code> is <code>hex_of_bytes raw</code> as a <code>string</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes_of_hex" class="anchored"><a href="#val-bytes_of_hex" class="anchor"></a><code><span><span class="keyword">val</span> bytes_of_hex : <span>string <span class="arrow">&#45;&gt;</span></span> bytes * int</span></code></div><div class="spec-doc"><p><code>bytes_of_hex hex</code> is <code>raw, error</code> decoded in constant time. Can be used to e.g. decode secrets from configuration files. The <b>contents can be secret</b>, but an attacker can learn the <b>length of</b> <code>hex</code> by timing this function.</p><p><b>Error handling:</b> The second tuple element <code>error</code> is <b>non-zero</b> when the length of <code>hex</code> is not a multiple of 2, or <code>hex</code> contains invalid characters. Implementations should ensure that `error = 0` before using <code>raw</code>. The function signals errors this way to allow implementations to handle invalid input errors in constant time.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">hex</span> <p>The hex-encoded octet string. Accepts characters <code>0-9 a-f A-F</code>. Note that <code>0x</code> prefixes or whitespace are not accepted.</p><p>Example:</p><pre><code>let serialized = &quot;2d2d486924&quot; in
let secret, error = string_of_hex serialized in
assert (error = 0);
(* secret is now [--Hi$] *)</code></pre></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_hex" class="anchored"><a href="#val-string_of_hex" class="anchor"></a><code><span><span class="keyword">val</span> string_of_hex : <span>string <span class="arrow">&#45;&gt;</span></span> string * int</span></code></div><div class="spec-doc"><p><code>string_of_hex hex</code> is <a href="#val-bytes_of_hex"><code>bytes_of_hex</code></a> <code>hex</code>, but returning a <code>string</code> instead of <code>bytes</code>. See <a href="#val-bytes_of_hex"><code>bytes_of_hex</code></a> regarding handling of invalid input errors.</p></div></div><h2 id="low-level-primitives"><a href="#low-level-primitives" class="anchor"></a>Low-level primitives</h2><h3 id="bithacks"><a href="#bithacks" class="anchor"></a>Bithacks</h3><div class="odoc-spec"><div class="spec value" id="val-one_if_not_zero" class="anchored"><a href="#val-one_if_not_zero" class="anchor"></a><code><span><span class="keyword">val</span> one_if_not_zero : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>one_if_not_zero n</code> is a constant-time version of <code>if n &lt;&gt; 0 then 1 else 0</code>. This is functionally equivalent to <code>!!n</code> in the C programming language.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero_if_not_zero" class="anchored"><a href="#val-zero_if_not_zero" class="anchor"></a><code><span><span class="keyword">val</span> zero_if_not_zero : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>zero_if_not_zero n</code> is a constant-time of <code>if n &lt;&gt; 0 then 0 else 1</code>. This is functionnaly equivalent to <code>!n</code> in the C programming language.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_of_bool" class="anchored"><a href="#val-int_of_bool" class="anchor"></a><code><span><span class="keyword">val</span> int_of_bool : <span>bool <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>int_of_bool b</code> is equivalent to <code>if b then 1 else 0</code>. Internally it cast with <code>%identity</code> instead of branching.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bool_of_int" class="anchored"><a href="#val-bool_of_int" class="anchor"></a><code><span><span class="keyword">val</span> bool_of_int : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>bool_of_int n</code> is equivalent to <code>if n = 0 then false else true</code>.</p></div></div><h3 id="composition"><a href="#composition" class="anchor"></a>Composition</h3><div class="odoc-spec"><div class="spec value" id="val-select_int" class="anchored"><a href="#val-select_int" class="anchor"></a><code><span><span class="keyword">val</span> select_int : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>select_int choose_b a b</code> is <code>a</code> if <code>choose_b = 0</code> and <code>b</code> otherwise. This comparison is constant-time and it should not be possible for a measuring adversary to determine anything about the values of <code>choose_b</code>, <code>a</code>, or <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-select_a_if_in_range" class="anchored"><a href="#val-select_a_if_in_range" class="anchor"></a><code><span><span class="keyword">val</span> select_a_if_in_range : <span>low:int <span class="arrow">&#45;&gt;</span></span> <span>high:int <span class="arrow">&#45;&gt;</span></span> <span>n:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>select_a_if_in_range ~low ~high ~n a b</code></p><ul><li>is <code>a</code> if <code>low &lt;= n &lt;= high</code> (in range)</li><li>is <code>b</code> is <code>n &lt; low || high &lt; n</code> (out of range)</li></ul><p>This function <b>only works for positive ranges</b>:</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">low</span> <p>invariant: <code>0 &lt;= low &lt;= max_int</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">high</span> <p>invariant: <code>low &lt;= high &lt;= max_int</code></p><p>This function can be used like <code>select_int</code> but using an integer range instead of zero/non-zero to select.</p><p>It operates in constant time and is safe to use with secret parameters for <code>low, high, n, a, b</code>.</p><p>Example:</p><pre><code>let a = 123 and b = 456 in
let x = select_a_if_in_range ~low:10 ~high:20 ~n:10 a b in
(* x = 123 *)
let x = select_a_if_in_range ~low:10 ~high:20 ~n:0 a b in
(* x = 456 *)
let x = select_a_if_in_range ~low:10 ~high:20 ~n:20 a b in
(* x = 123 *)
let x = select_a_if_in_range ~low:10 ~high:20 ~n:21 a b in
(* x = 456 *)

(* Constant-time subpatterns can be expressed by nesting,
   Below is a constant time version of:
   match 3 with
   | 1 | 2| 3 | 4 -&gt;
      begin match 3 with
      | 2 | 3 -&gt; 111
      | _ -&gt; 222
      end
   | _ -&gt; 333

*)
let n = 3
select_a_if_in_range ~low:1 ~high:4 ~n
  (select_a_if_in_range ~low:2 ~high:3 ~n
     (111)
     (222)
  )
  333
(* evalutes to 111 because [1 &lt;= n  &lt;= 4] selects the inner pattern
   and [2 &lt;= n &lt;= 3] selects the first branch (&quot;a&quot;) of the inner pattern.
*)

(* The applications can also be composed in constant time,
   note that all the branches are always evaluated, so large
   expressions can get slow:
*)
4
|&gt; fun n -&gt; select_a_if_in_range ~low:1 ~high:5 ~n
   (n * 10)
   (n - 100)
|&gt; fun n -&gt; select_a_if_in_range ~low:20 ~high 30 ~n
   (n * 100)
   (n+3)
(* evaluates to [4 *10 + 3] *)

(* Below the normal, non-constant time version: *)
4
|&gt; (function
     | n when 1 &lt;= n &amp;&amp; n &lt;= 5 -&gt; n * 10
     | n -&gt; n - 100)
|&gt; (function
    | n when 20 &lt;= n &amp;&amp; n &lt;= 30 -&gt; n * 100
    | n -&gt; n + 3)</code></pre><p>Another example of how to use this can be found in the implementations of <code>lowercase_ascii</code> and <code>bytes_of_hex</code>.</p></li></ul></div></div></div></body></html>